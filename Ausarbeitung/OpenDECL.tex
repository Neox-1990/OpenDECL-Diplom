\documentclass[hyperref,german,diplommedieninf,twoside]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% female	weibliche Titelbezeichnung bei Diplom
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig

\author{Ronald Großmann}
\title{Open Display Environment Configuration Language}
\birthday{6. April 1990}
\placeofbirth{Sebnitz}
\matno{3507432}
\betreuer{Dr. rer. nat. Sebastian Grottel}
\bibfiles{literatur}
\problem{
Die Anzahl der Multi-Display-Installationen nimmt in beinahe jeder Umgebung zu: angefangen von Desktopsystemen mit mehreren Monitoren, über Projektionsflächen mit mehreren Projektoren (aka Powerwalls) bis hin zu komplexen VR-Installationen wie Caves. Oft benötigen solche Display-Systeme leistungsstarke, parallel GPU-Cluster zur Bilderzeugung, allein um der notwendigen Pixelfüllrate gerecht werden zu können. Zusätzlich kommen in solchen Anlagen üblicherweise auch Tracking-Systeme zum Einsatz, die den Benutzer, also die physische Welt, mit den dargestellten Szenen, der künstlichen Welt, verbinden; auch im Desktop-Bereich, z.B. durch Windows Kinect oder Leap Motion. Um solche Systeme zu betreiben bedarf es komplexer Software. Diese ist oft im akademischen Umfeld entwickelt. Solche Software muss umfassend konfiguriert werden, einerseits was die verfügbare Rechnerinfrastruktur betrifft (welche Computer sind mit welchen Ausgabegeräten verbunden, welche Computer dienen rein zur entfernten Bilderzeugung und wie sind die Rechner miteinander vernetzt), andererseits auch was die logischen und physikalischen Parameter der Ausgabegeräte betrifft (virtuelle Desktop-Größen und Teile einzelner Beamer, physikalische Anordnung von Display oder Projektoren und Abgleich mit den Raumkoordinaten eines Benutzer-Trackings). Allerdings hat sich für diese Konfigurationen bisher kein Standard entwickelt.\\

In dieser Arbeit soll ein Vorschlag für so ein standardisiertes Konfigurationsformat auf Basis von XML entwickelt werden. Mittels XSLT soll es möglich sein, aus einer XML-Datei Konfigurationsdateien für unterschiedliche Programme zu erzeugen. Ein graphischer interaktiver Editor soll das Erstellen und Bearbeiten der XML-Dateien, sowohl der strukturellen Eigenschaften (Computer-Cluster-Architektur, inklusive GPUs und Display-Anschlüssen) als auch der 3D physikalischen Eigenschaften (Display-, Projekt-Setup) anschaulich und einfach ermöglichen. Das XML-Format muss sauber durch Namespaces aufgeteilt und erweiterbar sein, was auch durch entsprechende Funktionen im graphischen Editor reflektiert werden muss (z.B. muss es im Editor möglich sein, eigentlich nicht unterstütze Tags editieren und beim Abspeichern erhalten zu können). Die Erstellung von XSLT-Dateien muss durch den Editor NICHT unterstützt werden, ihre Anwendung zum Export der Konfiguration in entsprechende andere Formate jedoch schon.\\

Folgende Hardware-Installationen müssen unterstützt werden:\\
\begin{enumerate}
\item Desktop-Computer mit mehreren Monitoren (mindestens zwei) die nicht in einer gemeinsamen Ebene stehen.
\item Stereo-Powerwall durch zwei Beamer betrieben an einem Rechner (Powerwall an der Professur CGV)
\item Großfläche Displaywand mit mehreren Panels (Displaywand an der Professur Multimedia-Technologie)
\item Fünf-Wand-CAVE mit zehn Beamer (im VR-Labor des Lehrstuhls Konstruktionstechnik / CAD)
\end{enumerate}

Hierbei müssen die physikalischen Display- und Projektionsanordnungen unterstützt werden, und zusätzliche Infrastruktur, wie z.B. Computer, GPUs, Tracking-Systeme etc., sollen so weit wie möglich unterstützt werden.\\

Die Hardwareinstallationen sollen in ihrem physikalischen Raum, in Metern, frei definierbar sein. Ist kein Benutzertracking vorhanden, so muss eine Standardposition für den Benutzer (Blickpunkt) konfigurierbar sein.\\

Die Konfiguration der Rechnerinfrastruktur muss mindestens die Computer enthalten, die direkt an die Ausgabegeräte angeschlossen sind. Ihre Netzwerkverbindungen untereinander sollten enthalten sein. Eventuelle Compute-Cluster zur Bilderzeugung und ihre Netzwerkverbindungen untereinander, sowie zu den Ausgaberechnern sollten ebenfalls konfigurierbar sein.\\

Folgende Software muss unterstützt werden, indem ihre Konfigurationsdateien, mindestens aber der entsprechend dieser Arbeit relevante Teil der Konfigurationsdateien, erzeugt werden kann:\\
\begin{itemize}
\item[a,] MegaMol, bzw. mittels einer kleinen Bibliothek jede an der TUD selbst entwickelte Software
\item[b,] Paraview
\item[c,] Equalizer (optional)
\end{itemize}

Weitere Software soll nach Absprache mit dem Betreuer ebenfalls unterstützt werden.\\

Die Bearbeitung erfolgt mit diesen Teilzielen:\\
\begin{itemize}
\item Anforderungsanalyse auf Basis der vorgegebenen Display-Hardware und Konfigurationsspezifikationen der einzusetzenden Software
\item Literaturrecherche zur Large-Display- und VR-Software-Middleware und Konfigurationen. Auch zu allgemeinen Arbeiten zur Kalibrieren und Konfiguration solcher Hardware-System
\item Spezifikation der XML-basierten Konfiguration
\item Umsetzung des geforderten Editor-Prototypens inklusive XSLT-basiertem Export der Konfigurationen
\item Evaluierung im Kontext der vorgegebenen Display-Systeme durch Darlegung und Durchführung des kompletten Konfigurationsprozesses anhand der vorgegebene Software
\item Optional: Erweiterung des Editors um weitere Funktionalitäten zur semi-automatischen Erzeugung der Konfigurationsdateien
\item Optional: Code-Bibliothek zur direkten Nutzung der Konfigurations-Xml-Datei
\item Optional: Untersuchung weiterer Display-Konfigurationen (z.B. gekrümmter Projektionen) und weiterer Visualisierungs- und VR-Software
\end{itemize}
}

\abstracten{abstract text english}
\abstractde{Mit Open Display Enviroment Description Language (OpenDECL) stellt die vorliegende Diplomarbeit eine XML-Beschreibung für Large High Resolution Displays (LHRD) vor. Mit Hilfe von XSL Transformationen können aus diesen Beschreibungen die Konfigurationen für Anwendungen generiert werden, welche auf den entsprechenden LHRDs ausgeführt werden. Mit ausgewählten Anwendungen und LHRDs wurde dies erfolgreich getestet. Zum Bearbeiten und Anwenden von OpenDECL wird zusätzlich ein Editor zur Verfügung gestellt.}

\begin{document}
%Kapitel 1 #######################
\chapter{Einführung}
Ein Tiled Display beziehungsweise Large High Resolution Display (LHRD) im Sinne dieser Arbeit, beschreibt Installationen, bei denen mehrere Displays zu einem größeren Display zusammengesetzt werden. Im Falle von Monitoren, besteht das LHRD aus mehreren einzelnen Monitoren die ein gemeinsames Display darstellen. Dieses muss nicht in einer Ebene liegen, sondern kann auch eine Krümmung aufweisen. Im Falle von Projektoren besteht das LHRD aus mehreren Projektionsflächen für die Projektoren. Projektoren können auch auf ein und die selbe Fläche projizieren. Dabei können die Projektionen beispielsweise durch Farbfilter für jedes Auge wieder getrennt werden und so eine stereoskopische Abbildung erzeugt werden.\\
LHRD bieten den Vorteil eine große Pixeldichte auf einer großen Fläche darzustellen. Dadurch lassen sich Details lokal noch hochauflösend darstellen, während gleichzeitig das gesamt Bild und Kontext dargestellt werden kann. Diese Eigenschaften machen LHRD besonders attraktiv für Anwendungsgebiete, in denen viele Informationen gleichzeitig dargestellt werden oder der Kontext einer Information wichtig ist. Ein solches Anwendungsgebiet findet sich in der wissenschaftlichen Visualisierung. Hier lassen sich sich dank der Größe des Displays sehr viele Daten gleichzeitig darstellen. Auch für Kommando und Kontrollaufgaben finden LHRD Anwendung, beispielsweise im Militär oder in der Luftfahrt. Besonders konstruierte LHRD, wie beispielsweise die CAVE \cite{CAVE}, bieten dem Nutzer eine besonders immersive Umgebung. Diese kann in der Industrie zur Unterstützung beim Design benutzt werden, beispielsweise bei der Entwicklung in der Automobilindustrie.\\
Der Aufbau und Betrieb eines LHRD ist Aufwändig, weshalb diese Technologie noch nicht so weit verbreitet ist. Die Komponenten für ein LHRD müssen meist individuell ausgewählt und konfiguriert werden, da es einige Probleme beim Betrieb eines LHRD gibt, auf die im folgenden Eingegangen wird.

\section{Probleme}
Durch die hohe Anzahl der Pixel in LHRDs ist es nötig mehrere GPUs für die Bilderzeugung zu verwenden um in annehmbarer Zeit ein Bilder zu erzeugen. Gerade bei interaktiven Visualisierungen ist ein möglichst kurze Reaktionszeit und eine möglichst flüssiger Ablauf der Visualisierung erforderlich. Für gewöhnlich wird dafür ein Cluster aus mehreren Rechnern zur Bilderzeugung verwendet, wodurch sich weitere organisatorische Probleme ergeben. Zum einem kann die Berechnung von dem, was visualisiert werden soll, getrennt von der eigentlichen Bilderzeugung geschehen. Es gäbe dabei bestimmte Rechner die beispielsweise für die Simulation verantwortlich sind und Rechner die nur für Bilderzeugung und das entsprechende Darstellen auf dem LHRD verantwortlich sind. Die Daten, die dabei von Rechnern der Simulation zu den Rechnern der Bilderzeugung transportiert werden müssen, sind nicht besonders groß, da es sich nur um Geometrieinformationen und Grafikbefehle handelt. Jedoch ist die Zuordnung, welchen Teil der Simulation welcher Rechner der Bilderzeugung für den entsprechenden Teil des LHRD, den er abbildet, benötigt. Zum Anderem gibt es die Möglichkeit das Berechnen und Bilderzeugen auf einem oder mehreren Rechnern durch zu führen und die erzeugten Bilddaten dann an die Rechner zu schicken, die mit dem LHRD verbunden sind. Dabei erhalten die mit dem LHRD verbundenen Rechner nur die Bilddaten, die dem entsprechenden Teil des LHRD abbilden. Das Problem dabei die Größe der Bilddaten, die bei ausreichend hoher Bildrate, übertragen werden müssen. Bei beiden dieser Ansätze gibt es das große Problem der Synchronisation. Wenn die Simulation beziehungsweise Berechnung verteilt über mehrere Rechner geschieht, müssen diese untereinander Synchronisiert werden um konsistente Daten zu produzieren. Die Bildausgabe auf die einzelnen Displays des LHRD muss ebenfalls synchronisiert geschehen um ein gutes Ergebnis zu erzielen.\\
Ein weiterer Problembereich für LHRD ist die Kalibrierung und Einrichtung an sich. Gerade bei Projektor-basierenden LHRDs muss sehr genau kalibriert werden, um ein optimales Bild zu erhalten. Da die Geometrie der Projektion aus technischen Gründen nicht perfekt rechtwinkelig sein kann, ist es schwer eine möglichst verzerrungsfreie Abbildung zu erhalten. Wenn man mehrere Projektoren benutzt um ein LHRD zu erzeugen ist die Helligkeit der Projektion ein Problem. Diese ist je nach Projektor ungleich über die Projektionsfläche verteilt und gerade am Rand kommt es zu Problemen, wenn man einen möglichsten unauffälligen Übergang von einer in die anliegende Projektion erhalten möchte. An diesen stellen muss mittels Edge Blending die Helligkeit angepasst werden, sodass ein gleichmäßiger und unauffälliger Übergang zwischen den Projektionen entsteht. Oftmals werden bei solchen Systemen Spiegel benutzt, um die Projektionsstrahlen um zu lenken und somit räumlich kompaktere Installationen zu erhalten. Durch die zusätzliche Umlenkung durch Spiegel jedoch wird das Kalibrieren der Projektion schwieriger, da auch die Ausrichtung des Spiegels mit beachtet werden muss. Bei Monitor basierenden LHRD ist es etwas einfacher die Geometrie beziehungsweise Form des LHRD zu erhalten, da es einfacher ist die Monitore in einem regelmäßigen Gitter anzuordnen. Das größte Problem bei solchen LHRDs jedoch sind die Rahmen, die Zwangsläufig an jedem Monitor vorhanden sind. Auch wenn es inzwischen Monitor Modelle mit sehr schmalen Rahmen gibt, verhindern diese Rahmen nach wie vor den Eindruck, dass es sich um eine große, ununterbrochene Bildfläche handelt. Auch bei Monitoren gibt es Probleme mit der Helligkeitsverteilung, vor allem Rand. Diese ist auch bei Monitoren vom gleichen Modell von Exemplar zu Exemplar unterschiedlich.\\
Ein dritter Problembereich für LHRDs betrifft die Anwendungen, die auf dieses Systemen betrieben werden sollen. Da viele LHRD Installationen individuell gebaut und betrieben werden, ergibt sich eine sehr Heterogene Landschaft aller LHRDs. Dies hat zur Folge, dass Anwendungen oft individuell für einzelne LHRD Installationen entwickelt werden beziehungsweise bestehende Anwendungen umfangreich angepasst werden müssen. Dies schränkt die Portabilität dieser Anwendungen ein, da es nur wenige Standards oder portable Frameworks für die Entwicklung gibt.

%Kapitel 2 #######################
\chapter{Verwandte Arbeiten}
In \cite{6378981} wird die bisherige Forschung und Entwicklung an LHRDs evaluiert und vorgeschlagen, in welche Richtung sich die Forschung auf diesem Gebiet weiter gehen sollte. Bei diesen Vorschlägen wird vor allem versucht den Fokus vom LHRD an sich mehr auf die Anwendungen und den Nutzer dafür zu verlagern. Wie man LHRD konstruiert ist bekannt, doch an sich nicht trivial und mit immer wiederkehrenden Herausforderung . Deshalb sollte die Industrie stärker in die Produktion von LHRD einsteigen um so diese zu vereinfachen und damit die Entwicklung voran zu bringen. Die Größe von LHRDs bringt neue Herausforderungen bezüglich Interaktion und Wahrnehmung von Informationen, welche künftige Anwendungen für LHRDs berücksichtigen müssen.\\
In \cite{4856637} wird eine Übersicht über Geräte, Anwendungen und Techniken für LHRD gegeben. Die vorgestellte Hardware reicht von Multi Monitor und Multi Projektor Installationen über Stereo Displays und Head-Mounted Displays bis hin zu CAVE und Volumendisplays. Es werden verschiedene Anwendungen für Data Streaming und Distributed Rendering vorgestellt. Am Ende wird eine Liste vorgestellt, mit den zehn wichtigsten Forschungszielen für LHRDs.  \\
Wie LHRDs für alltägliche Arbeiten genutzt werden können, wurde anhand von Probanden in \cite{56912988} untersucht. Diese nutzten LHRD über 10 Monate für ihre täglichen Aufgaben. Anhand dieser Erfahrungen wurden Faktoren ermittelt, die bei der Entwicklung von Arbeitsplätzen mit LHRDs beachtet werden müssen. Das sind vor allem die Höhe und Krümmung des Displays. Aber auch die Position der Eingabegeräte und des Nutzers sind wichtig insbesondere deren Mobilität vor dem Display.\\
Das Problem der Maussteuerung auf LHRDs wird in \cite{4580342} versucht zu lösen. Aufgrund der Größe und Pixeldichte von LHRDs ist es schwierig mit der Maus gezielt zu arbeiten, da man nicht immer das Gesamte Display im Blick haben kann und so den Überblick, wo sich der Mauszeiger aktuell befindet, verliert. Außerdem schränkt die Maussteuerung die Bewegungsfreiheit vor dem LHRD ein. In dieser Arbeit wurde ein System entwickelt, in dem man mit Hilfe eines Laserpointer den Mauszeiger steuern kann. Dabei wird mit mehreren Kameras das LHRD mit einer möglichst hohen Bildrate beobachtet. Die Kameras sind so auf das LHRD kalibriert, dass eine Umrechnung von Kamerakoordinaten in Displaykoordinaten möglich ist. Damit wurde der Laserpunkt von den Kameras verfolgt und der Mauszeiger entsprechend positioniert. In der Evaluation zeigte sich jedoch, dass die Leistung der Benutzer mit diesem System hinter denen mit der Maus liegen.

\section{Betrieb von Large High Resolution Displays}
Mit Chromium wird in \cite{422242} ein Framework für interaktives Rendering auf Cluster vorgestellt. Dabei wird ein Stream aus Grafik-API-Befehlen (zum Beispiel OpenGL) durch die einzelnen Rechner im Cluster manipuliert. Dies geschieht in den Rechnern des Clusters. Diese können mehrere Streams empfangen, diese verarbeiten und manipulieren und dann an mehrere nachfolgende Rechner des Clusters als Stream wieder ausgeben. Zur Manipulation des Streams besitzt jeder Rechner im Cluster eine OpenGL Stream Processing Unit, die mit verschiedenen Funktionen den Inhalt des Stream transformiert. Weitere Teile von Chromium betreffen die Kommunikation innerhalb des Clusters zum Beispiel das ver- und entpacken von Streamdaten oder die Abstraktion des Netzwerkes damit eine Kommunikation zwischen verschiedenen Stream Processing Units stattfinden kann. All dies ermöglicht, dass der Algorithmus einer Anwendung die mit Chromium benutzt wird nicht verändert werden muss, da Chromium die Ausgabe der Anwendung als Stream übernimmt und die Ausgabe auf ein LHRD ausführt. Die nötigen Korrekturen und Transformation geschehen im Cluster. \\
In \cite{Jeong_scalablegraphics} wird mit SAGE (Scalable Adaptive Graphics Environment) eine Schnittstelle zwischen Applikation und LHRD vorgestellt. Mit SAGE ist es möglich mehrere Bilderzeugungsquellen, beispielsweise Simulationen oder Visualisierungen, zusammen zu führen und auf einem LHRD aus zu geben. Die Anzeige der einzelnen Quellen auf dem LHRD lassen sich beliebig skalieren und positionieren. Damit mit die Quellen mit SAGE verarbeitet werden können, müssen diese für das SAGE Framework angepasst werden. Dies besteht darin, dass bestimmte Befehle für die SAGE Application Interface Library hinzugefügt werden. Diese regelt die Kommunikation und den Transport des Outputs der Applikation an SAGE.\\
In \cite{156748} werden zwei Ansätze vorgestellt, wie Anwendungen auf Cluster betriebenen Displays betrieben werden können. Der erste Ansatz beschreibt eine Master-Slave Architektur bei der die Ausgabe auf die für die Bilderzeugung zuständigen Rechner verteilt wird. Für die Umsetzung dieses Ansatzes werde zwei Vorschläge gemacht. Zum einem ein spezieller Treiber für die GPU, welcher die Primitive und Befehle die an die GPU geschickt werden abfängt und an die Rechner für die Bilderzeugung weiterschickt. Zum anderem eine spezielle \textit{OpenGL32.dll}, welche die Befehle und Daten zur Bilderzeugung nicht an die GPU, sondern an die Rechner für die Bilderzeugung übertragen wird. Dabei müsste jedoch die entsprechende Anwendung an diese \textit{OpenGL32.dll} angepasst werden. Der zweite Ansatz ist der, des synchronen Ausführen des Programmes. Dabei wird angenommen, dass ein und die selbe Anwendung auf den Rechnern für die Bilderzeugung gleichzeitig synchron ausgeführt wird. Für die Umsetzung dieses Ansatzes werden auch zwei Vorschläge gemacht. Zum einem eine Synchronisation des Systems in der die Anwendung ausgeführt wird mit den Systemen auf den anderen Rechnern. Dafür müssen die Systeme untereinander Informationen über ihren Status austauschen, um synchron zu bleiben. Zum Anderem eine Synchronisation Anwendung selbst mit den Anwendungen auf den anderen Rechnern. Auch hier müssen Informationen über den Status ausgetauscht werden, was hier auf der Ebene der Anwendung geschieht. Für diesen Vorschlag müsst die Anwendung entsprechend angepasst werden.


\section{Kalibrierung von Large High Resolution Displays}
PixelFlex \cite{68109} ist ein Projektor-basierendes LHRD, welches aus bis zu 8 Projektoren besteht. Diese projizieren über individuell neig- und schwenkbare Spiegel auf eine Projektionsfläche. Die Spiegel sowie die Fokussier- und Zoomfunktionen der Projektoren waren von einem Rechner steuerbar. Zusätzlich gibt es eine Kamera zur Kalibrierung. Ziel des PixelFlex Systems ist es, automatisch eine Abbildung von Projektorkoordinaten in Weltkoordinaten zu finden, so dass eine verzerrungsfreie und gleichmäßig helle Projektion von allen Projektoren auf die Projektionsfläche stattfindet. Dies geschieht über die Kamera, wobei zunächst die Abbildung von Weltkoordinaten in Kamerakoordinaten ermittelt wird. Über diese wird dann die Abbildung von Weltkoordinaten in Projektorkoordinaten ermittelt für jeden einzelnen Projektor. Mit dieser Abbildung lassen sich die Ausgaben an die Projektoren so konfigurieren, dass ein LHRD entsteht. Zur Anpassung der Helligkeit an den Übergängen, wo sich mehrere Projektionen überlappen, werden Alphamasken benutzt. Diese blenden softwareseitig Teile des Bildes für entsprechende Projektoren aus, sodass die Projektionen nicht mehr überlappen und somit eine gleichmäßige Helligkeit über das LHRD erreicht wird.\\
Für die Kalibrierung eines Projektor-basierenden LHRD mit einer gekrümmten Projektionsfläche wird in \cite{10.1111:j.1467-8659.2009.01676.x} ein System vorgestellt. Die Kalibrierung erfolgt mit Hilfe einer Kamera, die auf einer schwenk- und neigbaren Plattform installiert ist. Dabei nimmt die Kamera in verschiedenen Stellungen Bilder der gekrümmten Projektionsfläche auf, wobei auf ausreichender Überlappung der Bilder zueinander zu achten ist. Zusätzlich werden von den verschiedenen Projektoren spezielle Bilder zur Kalibrierung projiziert. Mit diesen Daten können für jeden Projektor entsprechend Korrekturen und Verzerrungen berechnet werden, die eine optimale Darstellung des LHRD auf der gekrümmten Projektionsfläche ermöglichen.\\
In \cite{chen2000automatic} wird die Kalibrierung eines Projektor-basierenden LHRD mit Hilfe einer Kamera vorgestellt, der ohne die Kalibrierung der Kamera funktioniert. Statt einer Abbildung der Weltkoordinaten der Projektionsfläche über die Kamerakoordinaten in die Projektorkoordinaten zu finden, geschieht dies hier über einen heuristische Optimierung mittels Simulated Annealing. Das Ziel dieser Optimierung ist eine Abbildung zu finden, welche den Abstand zweier Punkte, die von verschiedenen Projektoren projiziert werden, minimiert. Dabei wird angenommen, dass die Punkte die gleiche Stellen auf der Projektionsfläche beschreiben.\\
Welche Probleme beim Bau eines Projektor-basierenden LHRD mit stereoskopischer Abbildung auftreten und deren mögliche Lösungen werden in \cite{bresnahan2003building} vorgestellt. Das LHRD dieser Arbeit bestand aus einem drei mal vier Gitter von Projektionsflächen, wobei jede Projektionsfläche von jeweils zwei Projektoren bestahlt wurde. Da eine perfekte Recheckige Projektion, aufgrund von leichten Verzerrungen die bei jedem Projektor auftreten, nicht möglich war, mussten verschiedenen Maßnahmen ergriffen werden. Für die grobe Kalibrierung wurden die Projektoren mechanisch positioniert und orientiert. Bei stereoskopischen Abbildungen, wie in diesem Fall, gibt es zusätzlich das Problem, dass für ein optimales Ergebnis, beide Projektionen von ein und der selben Position ausgehen müssen, was physikalisch nicht möglich ist. Die wird versucht mithilfe von speziellen Projektoren zu lösen, die eine off-axis Projektion mithilfe von Lens-Shifting ermöglichen. Die feine Kalibrierung der Projektionsgeometrie erfolgt dann softwareseitig mithilfe von Verzerrungen, sodass man für jeden Projektor eine horizontale und vertikale linientreue Projektion erhält, wobei die Projektionen der Paare von Projektoren, die auf ein und die selbe Projektionsfläche projizieren, deckungsgleich sind. Für den Übergang zwischen den sich überlappenden Projektionsflächen wurde Edge Blending mithilfe einer softwareseitigen Alphamaske verwendet. Eine hardwareseitige Lösung mittels spezieller Blenden, die an den Projektoren installiert werden, wurde auch in Betracht gezogen. \\
Mit XMegaWall wird in \cite{4485564} ein Projektor-basierendes LHRD vorgestellt, welches aus 28 Projektoren besteht, die in einem sieben mal vier Gitter angeordnet sind. Alle Projektoren stehen dabei in einem Gerüst, wobei jeder einzelne Projektor auf einer speziellen Halterung montiert ist. Diese Halterung erlaubt die mechanische Feinjustierung der einzelnen Projektoren.\\
Für nicht planare Projektor basierende LHRDs wird in \cite{6378981} eine Methode für eine automatische Kalibrierung mit Hilfe einer Kamera vorgestellt. Dabei wird die gesamte Projektionsfläche des LHRD als Translationsfläche bestehend aus einem Profil und einem Pfad betrachtet. Über zwei nichtlineare Optimierungen werden zunächst die Kameraparameter bestimmt um damit anschließend die dreidimensionale Form der Projektionsfläche zu rekonstruieren. Dabei kann die Kamera auf einer schwenk- und neigbaren Plattform gedreht werden um das gesamte LHRD zu erfassen. Mit Hilfe eines projizierten Musters jedes Projektors, kann nun eine Abbildung von Projektorkoordinaten in Weltkoordinaten berechnet werden und somit die Projektion auf die Projektionsfläche entsprechend angepasst werden.\\
Für Projektoren mit Weitwinkel Linsen wird in \cite{4161017} ein Algorithmus vorgestellt, mit dem Verzerrungen durch Linse und nicht planarer Projektionsfläche korrigieren lassen. Der Vorteil bei Projektoren mit Weitwinkel Linsen liegt darin, dass auch mit einem geringen Abstand zur Projektionsfläche eine große Projektion erreicht werden kann. Jedoch erzeugen diese Weitwinkel Linsen erhebliche Verzerrungen. Der in dieser Arbeit vorgestellte Algorithmus ermittelt zunächst die geometrische Form der Projektionsfläche. Dies geschieht mittels strukturiertem Licht des Projektors und einer kalibrierten Stereokamera. Anschließend wird die Verzerrung der Linse ermittelt und zusammen mit der geometrische Form der Projektionsfläche eine Vorverzerrung des Bildes für den Projektor berechnet, damit eine optimale Projektion auf die Projektionsfläche stattfindet.\\
In \cite{5710903} wird eine Technik zur Kalibrierung von Projektor-basierenden LHRD mit einer Kamera beschrieben. Unter den Bedingungen, dass die Projektionsfläche vertikal extrudiert ist, dass das Seitenverhältnis des Rechteckes, welches die vier Ecken der Projektionsfläche aufspannen, bekannt ist und die Grenze der Projektionsfläche sichtbar sowie segmentierbar ist, kann dies mit einer nicht kalibrierten Kamera geschehen. Zunächst wird mit Hilfe eines Bildes der Projektionsfläche die Kameraposition und Orientierung sowie die dreidimensionale Geometrie der Projektionsfläche ermittelt. Dann wird für jeden Projektor anhand eines projizierten Musters dessen Parameter bestimmt und damit eine Abbildung von Projektorkoordinaten in Weltkoordinaten auf der Projektionsfläche.


\section{Middleware für Anwendungen auf Large High Resolution Displays}
In \cite{6143028} wird ein Ansatz vorgestellt, wie verschiedene heterogene Applikationen zu einer VR-Anwendung verknüpft werden können. Dies geschieht, in dem man die einzelnen Applikationen zu Modulen kapselt, die nur noch über entsprechend spezifizierte input und output ports kommunizieren. Die Kommunikation erfolgt über Messages in denen die Daten zur Weiterverarbeitung an das entsprechende Modul gesendet werden. Dieser Ansatz einer Message Oriented Middleware bietet den Vorteil, dass die einzelnen Module, austauschbar sind, solange die input und ouput ports gleich spezifiziert sind. Der Message Manager der Middleware steuert dann den Event basierenden Ablauf einer Anwendung mit Datenverteilung und Lastbalancierung. Die Bilderzeugung und Konfiguration erfolgt in den Modulen.\\
Einen ähnlichen Ansatz verfolgt FlowVR \cite{1847038} welches eine Middleware darstellt die vor allem für verteilte VR-Anwendungen auf Cluster konzipiert ist. Auch hier sollen heterogene Einzelkomponenten zu einer gesamt VR-Anwendung verknüpft werden, ohne den bestehenden Code der Einzelkomponenten zu stark zu verändern. Das Hauptaugenmerk liegt dabei auf der Kommunikation und Synchronisation innerhalb des Clusters. Ähnlich zu \cite{6143028} haben die einzelnen Module input und output ports, die mit anderen Modulen verbunden sind. Die Kommunikation läuft auch hier über Messages. Dabei gibt es spezielle Messsages zur Synchronisation, womit beispielsweise eine gleichmäßige Bildrate für die Ausgabe auf ein LHRD erzielt wird, wenn dieses LHRD von mehreren Rechnern des Cluster betrieben wird.\\
Im Falle der CAVE \cite{Cruz-Neira:1992:CAV:129888.129892} handelt es sich um ein besonderes LHRD. Da der Nutzer sich in einem Raum befindet, der von mehreren Seiten projiziert wird, bekommt der Nutzer eine besonders immersive Erfahrung. Die Entwicklung von VR-Anwendungen für solche Installation ist durch die nicht einfach, da es eine Vielzahl an Ein- und Ausgabegeräten gibt, für die die Anwendung angepasst werden muss. In \cite{4077770} wird mit dem VR Juggler eine virtuelle Platform zu Entwicklung und Ausführung von VR-Anwendungen in CAVE Installationen vorgestellt. Das Ziel hierbei war, den Entwicklern der VR-Anwendungen einfache Software Werkzeuge zu geben und gleichzeitig die Komplexität der Hardware Konfiguration weg zu kapseln. Damit sollen sich Entwickler voll auf die eigentliche VR-Anwendung konzentrieren können und eine einfache Basis zum Entwickeln, Testen und Ausführen haben. Dabei agiert VR-Juggler ähnlich der Virtuellen Maschine bei JAVA, wie eine zusätzliche Schnittstelle zwischen Anwendung und Hardware. Dadurch entstehen nur geringe oder nicht messbare Leistungsnachteile. Eine Anwendung, die einmal für den VR-Juggler entwickelt wurde, läuft also auf allen Installationen, die VR-Juggler unterstützt.\\
Mit HIVE wird in \cite{1766189} und \cite{2435429} ein Middleware Framework vorgestellt für die Entwicklung verteilter VR-Anwendungen. Besonderes Augenmerk wurde dabei auf die Skalierbarkeit bezüglich des Clusters, die Effizienz der Server und eine offene Plattform gelegt. Dabei arbeitet im Hintergrund ein System aus drei Schichten. In der untersten Schicht sind die Nutzer, die aktiv oder passiv in einer Virtuellen Umgebung teilnehmen kann. In der mittleren Schicht agiert ein Group Manager Prozess, der die Virtuelle Umgebung spezifiziert und die Nutzer verwaltet. In der obersten Schicht agiert ein Group Agent Prozess, der die verschiedenen Group Manager Prozesse verwaltet, sowie ein Directory Manager Prozess, der die Kommunikation, das Lastbalancieren der Nutzer und damit die Wurzel des Systems ist.\\
Mit InTml wird in \cite{581051} eine Beschreibung für VR-Anwendungen vorgestellt. Dabei werden verschiedene Eingabegeräte, Ausgabegeräte und Interaktionstechniken beschrieben und zusammen mit entsprechenden Geometriedaten zu Anwendungen verknüpft. Das Konzept besteht aus einem Datenflussmodell, bei dem die verschiedenen Elemente über Inputports und Outputports verbunden sind und die Daten verarbeiten und weitergeben. Die Beschreibung der einzelnen Elemente liegt dabei als XML Datei vor, in dem beschrieben wird, was dieses Element macht und welche Daten es verarbeiten kann und welche es anschließend weiter gibt. Die Verbindungen zwischen den einzelnen Elementen wird ebenfalls in einer XML Datei beschrieben.\\
Vrui VR Toolkit \cite{VRUI} versucht ein Tool-Kit für die Entwicklung von VR-Anwendungen zur Verfügung zu stellen. Dabei wird versucht die Ausgabe auf Displays, die verteilte Berechnung in einem Cluster und die Eingabe mit verschiedenen Eingabegeräten so gut es geht zu abstrahieren. Damit sollen Entwickler entlastet werden, da sie sich nicht mehr um die spezielle Implementierung dieser Aspekte für konkrete Installationen kümmern müssen. Die Anwendungen werden für diese abstrahierten Aspekte entwickelt. Um diese Anwendungen dann auf verschiedenen Installationen zu betreiben, werden mit Konfigurationsdateien die konkreten Hardwareelemente beschrieben und mit Vrui in die abstrahierten Aspekte übersetzt. Somit kann man ein und die selbe VR-Anwendung auf verschiedenen Installationen betreiben und muss dafür lediglich die Konfigurationen anpassen.



\section{Einordnung meiner Arbeit}
Diese Arbeit befasst sich mit dem Thema der Kalibrierung von Anwendungen für LHRDs. Es stellt ein Hilfsmittel für Anwendungen auf LHRDs dar. Dabei verfolgt die Arbeit einen Ansatz der in den von mir recherchierten Arbeiten noch nicht behandelt wurde. Diese Arbeit konzentriert sich dabei auf die Konfiguration und die Anordnung des LHRD an sich. Die Konfiguration der Infrastruktur zum Betrieb eines LHRD steht dabei eher im Hintergrund, wird jedoch auch mit aufgegriffen. Diese Arbeit stellt ein Hilfsmittel zur Verfügung, mit der bestehende Anwendungen auf Basis einer Beschreibung des LHRD, individuell konfiguriert werden können.

%Kapitel 3 #######################
\chapter{Anforderungsanalyse}
Die Herausforderung der Aufgabenstellung bestand darin, die verschiedensten LHRD Installationen auf die essentiellen Aspekte zu reduzieren und damit eine gemeinsame abstrakte Beschreibung zu finden. Dabei sollten nur die wichtigsten Aspekte teil der Beschreibung sein, jedoch genügend, um die Konfiguration der Anwendungen zu erstellen. Ziel ist ein Standard der in der Lage ist jedes LHRD zu beschreiben.\\
\\
Im Zuge der Anforderungsanalyse, habe ich die in der Aufgabenstellung genannte Hard- und Software analysiert. Dabei habe ich mich im Falle der Hardware vor allem auf die Anordnung und Zusammensetzung der Displayelemente konzentriert, welche das LHRD bilden. Dabei ging es einerseits um die rein physischen Maße und Gegebenheiten, aber auch die Infrastruktur dahinter. Wie die Displayelemente angesteuert und abgebildet werden ist ein wichtiger Aspekt.\\
In der Softwareanalyse habe ich mich auf die Konfiguration der Anwendungen konzentriert. Insbesondere die Konfigurierbarkeit der Bildausgabe war für meine Arbeit wichtig. Dies betraf die genaue Positionierung der Ausgabefenster als auch die Abbildung aus der Anwendung auf dieses Ausgabefenster. Ich habe jede der zu unterstützenden Softwarepakete auf den verschiedenen Hardwareinstallationen untersucht.

\section{Hardwareanalyse}
Im folgenden werden die verschiedenen Hardware Installationen beschrieben, welche ich in meiner Arbeit analysiert habe. Für die vier Installationen gibt es eine schematische Abbildung (Abb. \ref{fig:Desktopschema}, Abb. \ref{fig:CGVschema}, Abb. \ref{fig:MTschema}, Abb. \ref{fig:CAVEschema}) welche auf der linken Seite die Infrastruktur darstellt und auf der rechten Seite den Aufbau des entsprechenden LHRD.\\
\subsection*{Desktop Systeme}
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.0\textwidth]{img/CGV-Aufbau.png}
	\caption{Schematische Darstellung des Desktop Systems}
	\label{fig:Desktopschema}
\end{figure}
Eine der Installationen ist ein Desktop System mit mindestens zwei Displays, die nicht zwangsläufig in einer Ebene liegen müssen. Grundsätzlich betrachte ich ein solches Desktop System als LHRD, wenn der Desktop auf die Displays erweitert wird. Dabei hat jedes Pixel der Displays eine eindeutige Desktop Pixel Koordinate. Das Referenz System, was mir zur Verfügung stand, bestand aus einem Notebook mit einem LCD Display. Dieses hatte eine Auflösung von 1280 x 800 Pixel, sowie eine physikalische Größe von 331 x 207 mm. An dieses Notebook ist ein LED Monitor angeschlossen und steht rechts neben dem Notebook, so dass die Oberkanten beider Displays auf gleicher Höhe sind. Der Monitor hat eine Auflösung von 1920 x 1080 Pixel, sowie eine physikalische Größe von 464 x 260 mm. Da beide Displays einen Rahmen haben, können sie nicht lückenlos nebeneinander stehen sondern haben einen Abstand von 28 mm.\\ 
Als Betriebssystem lag Windows 7 vor, welches so eingerichtet wurde, dass der LCD Bildschirm des Notebooks der Hauptbildschirm war und somit in dessen oberen linken Ecke der Ursprung des Pixelkoordinatensystem lag. Der Desktop wurde dann nach rechts auf den LED Monitor erweitert. Daraus folgte, dass die linke obere Ecke des LED Monitors die Pixelkoordinaten (1280;0) hatte.

\subsection*{CGV Stereowall}
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.0\textwidth]{img/CGV-Aufbau.png}
	\caption{Schematische Darstellung der Stereopowerwall des Computergraphik Lehrstuhls}
	\label{fig:CGVschema}
\end{figure}
Bei der Stereopowerwall der Professur für Computergraphik und Visualisierung handelt es sich um ein Projektor-basierendes LHRD. Dabei sind zwei Projektoren an eine GPU eines Rechners angeschlossen (Abb. \ref{fig:CGVschema} links). Das Bildsignal an einen der beiden Projektoren wird noch einmal gedoppelt um es an einem Monitor anzuzeigen (Abb. \ref{fig:CGVschema} P1 und M). Dieser Monitor dient zur vereinfachten Bedienung des Rechners. Die Besonderheit dieser Installation besteht darin, dass beide Projektoren auf ein und die Selbe Projektionsfläche strahlen und die Projektionen für eine stereoskopische Abbildung möglichst deckungsgleich aufeinander liegen (Abb. \ref{fig:CGVschema} rechts). Dazu wurden die beiden Projektoren direkt übereinander montiert und entsprechend eingestellt. Um Platz zu sparen werden die Strahlen über einen Spiegel umgelenkt, bevor sie von Hinten auf die Projektionsfläche treffen. Vor beiden Projektoren sind Polarisationsfilter so montiert, dass sich die Polarisation der Strahlen beider Projektoren um 90° unterscheidet. Die Projektionsfläche besteht aus einem Stoff, der diese Polarisation erhält und somit zusammen mit einer entsprechenden Polarisation Stereobrille ein getrenntes Bild für das linke und rechte Auge darstellt. Die Projektionsfläche hat eine Größe von 2720 x 2040 mm. Die beiden Projektoren haben eine Auflösung von 1400 x 1050 Pixel.\\
Der Rechner an den die Projektoren und der Monitor angeschlossen waren, hatte unter anderem Windows 7 als Betriebssystem, welches ich genutzt habe. Dabei war der Desktop über beide Projektoren erweitert, die Gesamtgröße des Desktops betrug also 2800 x 1050 Pixel. Dabei war der Projektor, der für das linke Auge projizierte, auch der linke Teil des Desktops. Dies war auch der Teil, der auf dem zusätzlichen Monitor angezeigt wurde. Dementsprechend wurde der rechte Teil des Desktop von dem Projektor dargestellt, welche für das rechte Auge projizierte.

\subsection*{MT Powerwall}
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.0\textwidth]{img/Powerwall-Aufbau.png}
	\caption{Schematische Darstellung der Powerwall des Lehrstuhl für Multimedia-Technologie}
	\label{fig:MTschema}
\end{figure}
Bei der Powerwall des Lehrstuhl für Multimedia-Technologie handelt es sich um ein LHRD bestehend aus zwölf Monitoren die in einem vier mal drei Gitter angeordnet sind (Abb. \ref{fig:MTschema} rechts). Jeder dieser Monitore hat eine Auflösung von 1920 x 1080 Pixel, sowie eine physikalische Größe von 1210 x 680 mm. Das gesamte LHRD hat also eine Auflösung von 7680 x 3240 Pixel, sowie eine metrische Größe von 4855 mm horizontal und 2050 mm vertikal. Die Rahmen um die Monitore sind mit 2,5 mm äußerst schmal.\\
All diese Monitore werden von einem Rechner mit zwei GPUs betrieben. An jeder GPU sind sechs Monitore angeschlossen (Abb. \ref{fig:MTschema} links). Auch auf diesem Rechner stand unter anderem Windows 7 als Betriebssystem zur Verfügung, welches ich benutzt habe. Der Desktop war über alle zwölf Monitore erweitert mit dem Monitor in der linken oberen Ecke als Hauptmonitor. Dadurch lag der Ursprung des Pixelkoordinatensystem für den gesamten Desktop auch in der linken oberen Ecke.\\
Trotz der zwei leistungsstarken GPUs, hatte das System unter Windows manchmal Probleme mit der großen Pixelzahl. Gerade bei Testen der Softwarepakete kam es des öfteren zu Abstürzen oder Bildfehler für einige Monitore, welche das Testen erschwerte.

\subsection*{CAVE}
\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.0\textwidth]{img/CAVE-Aufbau.png}
	\caption{Schematische Darstellung der Fünf-Seiten-CAVE des Lehrstuhl Konstruktions\-technik/CAD}
	\label{fig:CAVEschema}
\end{figure}
Bei der CAVE des Lehrstuhl Konstruktionstechnik/CAD handelt es sich um ein Projektor-basierendes LHRD. In diesem Fall handelt es sich um eine Fünf-Seiten-CAVE, bei der nur die Seite nicht für die Projektion benutzt wird, durch die man die CAVE betritt. Die restlichen fünf Seiten werden von hinten jeweils von zwei Projektoren deckungsgleich bestrahlt. Jede der Seiten hat eine Größe von 3600x 2700 mm (Abb. \ref{fig:CAVEschema} rechts). Da die Seiten nicht quadratisch sondern rechteckig mit einem Verhältnis von vier zu drei sind, kommt es zu einer Diskrepanz zwischen den Seiten links und rechts (Abb. \ref{fig:CAVEschema} rechts L und R) und den Seiten oben und unten (Abb. \ref{fig:CAVEschema} rechts T und B). Dadurch reichen die Seiten oben und unten nicht ganz bis zum Eingang der CAVE. Jeder der zehn Projektoren hat eine Auflösung von 1600 x 1200 Pixel. Im Gegensatz zur Stereopowerwall der Professur für Computergraphik und Visualisierung, werden hier die Bilder für linkes und rechts Auge durch einen Interferenzfilter getrennt. Dabei werden mehrere Wellenlängen der Strahlen jeweils gefiltert, sodass mit einer entsprechenden Brille die Bilder für die Augen wieder getrennt wahrgenommen werden. Auch hier werden mittels Spiegel die Stahlen umgelenkt um Platz zu sparen.\\
Jeder der zehn Projektoren ist mit jeweils einem separaten Rechner verbunden. Diese zehn Rechner und ein zusätzlicher Rechner sind durch ein Ethernet Netzwerk verbunden (Abb. \ref{fig:CAVEschema} links). Der zusätzliche Rechner hat einen eigenen Monitor außerhalb der CAVE. Dieser spezielle Rechner dient zum Steuern der anderen 10 Rechner via Remote Control. Zusätzlich verarbeitet dieser Rechner die Tracking Daten und sendet sie an die 10 Rechner mit den Projektoren. Auf allen Rechnern ist Windows XP als Betriebssystem installiert. Aufgrund der speziellen Treibersoftware für die GPUs und der Software zum betreiben der CAVE, konnte noch nicht auf ein aktuelleres Betriebssystem umgestiegen werden.

\section{Softwareanalyse}
In der Softwareanalyse habe ich mich auf die Konfigurierbarkeit der einzelnen Anwendungen konzentriert. Die betrifft hauptsächlich die Konfiguration der Bildausgabe. Dabei geht es einerseits um die Positionierung der Ausgabe, also wie kann ich das Fenster der Ausgabe den Anforderungen entsprechend positionieren. Auch die Anpassung des Viewports, zum Beispiel bezüglich des FOV oder der Blickrichtung, sollte konfigurierbar sein. Bei Stereoprojektionen ist es zudem wichtig, die einzelnen Ausgaben für linkes und rechtes Auge zu
\subsection*{MegaMol}
Bei MegaMol handelt es sich um ein Softwaresystem zur Visualisierung von Punkt-basierenden Datensätzen \cite{grottel2014megamol}. \\
MegaMol-Projekte bestehen aus einem Graph verschiedener Berechnungsmodule, die auf den Datensatz angewandt werden. Dabei können Projekte auch in mehreren Instanzen gestartet werden, welche dann jeweils auch ein eigenes Ausgabefenster besitzen. Für das Rendern auf mehrere verteilte Displays bietet MegaMol einen konfigurierbaren TileView-Modul an. In diesem lassen sich auch die Stereoeigenschaften konfigurieren.\\
Die Konfiguration erfolgt an zwei Stellen. Zum einem in der Datei \textit{megamol.cfg} wo für verschiedene Fenster die Größe und Position festgelegt werden kann. Der Name des Fensters ist dabei der Name der Instanz, den man beim Starten des Projektes angibt, gefolgt von "'-window"' (Abb. \ref{lst:MegaMolCFGExample}). Die Werte im \textit{value} Attribut stehen dabei der Reihenfolge nach für die x- und y-Koordinaten der linken oberen Fensterecke sowie die Breite und Höhe des Fensters in Pixel. Die Konfiguration der TileView erfolgt dann über eine Parameter-Datei, die beim Starten des Projektes mit übergeben wird. Darin werden die Eigenschaften der einzelnen Module für jede Instanz gespeichert (Abb. \ref{lst:MegaMolParamFileExample}). Für TileView sind das die Stereoeigenschaften (Abb. \ref{lst:MegaMolParamFileExample} erste und zweite beziehungsweise fünfte und sechste Zeile), Die Position und Größe des Tiles innerhalb des Viewports (Abb. \ref{lst:MegaMolParamFileExample} dritte beziehungsweise siebte Zeile) sowie die Gesamtgröße des Viewports (Abb. \ref{lst:MegaMolParamFileExample} vierte beziehungsweise achte Zeile). Dabei sind die Angaben der Position und Größe nicht an eine bestimmte Einheit gebunden. Mit diesen Konfigurationen lassen sich beliebig Tiles positionieren und anpassen.\\
Mit diesen Konfigurationen habe ich MegaMol erfolgreich auf dem Desktop System und der Powerwall des Lehrstuhl für Multimedia-Technologie getestet. Auf der Stereopowerwall der Professur für Computergraphik und Visualisierung habe ich MegaMol auch erfolgreich mit der Stereoprojektion getestet. Da MegaMol noch kein Modul besitzt, mit dem man mehrere Viewports erzeugen kann, die verschiedene Blickrichtungen haben, war MegaMol ungeeignet für einen Test in der CAVE des Lehrstuhl Konstruktionstechnik/CAD.
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
<set name="tile1-window" value="x0y0w1400h1050nd" />
<set name="tile2-window" value="x1400y0w1400h1050nd" /> 
\end{lstlisting}
\caption{Konfiguration der Ausgabefenster in \textit{megamol.cfg}}
\label{lst:MegaMolCFGExample}
\end{figure}
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
::tile1::TileView1::eye=Left Eye
::tile1::TileView1::projType=Stereo OffAxis
::tile1::TileView1::tile=0.000000;0.000000;1400.000000;1050.000000
::tile1::TileView1::virtSize=1400.000000;1050.000000
::tile2::TileView1::eye=Right Eye
::tile2::TileView1::projType=Stereo OffAxis
::tile2::TileView1::tile=0.000000;0.000000;1400.000000;1050.000000
::tile2::TileView1::virtSize=1400.000000;1050.000000
\end{lstlisting}
\caption{Konfiguration der Tile-Views in Parameter Datei}
\label{lst:MegaMolParamFileExample}
\end{figure}
\subsection*{ParaView}
ParaView \cite{ahrens200536} ist eine open-source Plattform auf Basis von VTK \cite{vtk2004} für die Analyse und Visualisierung von Daten. Die von mir benutzte Version von ParaView ist die vor kompilierte Desktop-Version 4.3 für Windows. Diese besitzt ein auf QT basierenden Interface. \\
Leider lässt sich die Ausgabe in diesem Interface nicht konfigurieren. ParaView bietet jedoch die Möglichkeit für Remote Rendering. Dafür wird ein ParaView Render Server mit Hilfe von MPI gestartet mit dem sich dann der ParaView Client verbinden kann. Dies funktioniert auch wenn der Server auf dem gleichen Rechner wie der Client läuft, mittels localhost. Beim Starten des Servers kann man diesen mittels Startparameter konfigurieren (Abb. \ref{lst:ParaViewCmdExample}). Dabei gibt es die Möglichkeit, die Ausgabe auf dem Rechner des Servers zu erzeugen. Diese Ausgabe lässt sich dann mittels einer Konfigurationsdatei genauer einstellen. Die Konfigurationsdatei wird auch als Startparameter beim Starten des Servers übergeben und ist XML Formatiert. Diese PVX-Dateien (Abb. \ref{lst:ParaViewPVXExample}) konfigurieren die Ausgabe für die Render Server. \textit{Machine} beschreibt den Rechner auf dem der Server läuft. Dabei ist das Attribute \textit{Name} der Name des Rechners. Im Falle eines Clusters, lassen sich also auch die Ausgaben auf mehreren Rechnern konfigurieren. Die weiteren Attribute konfigurieren die Ausgabe. \textit{Geometry} konfiguriert die Größe und Position des Ausgabefenster. Dabei sind die ersten beiden Werte die Größe des Fensters in Pixel und die letzten beiden Werte die x- und y-Koordinate der linken oberen Fensterecke. \textit{LowerLeft, LowerRight} und \textit{UpperRight} sind drei Raumvektoren, die die entsprechenden Ecken des Displays im Raum beschreiben. Das hierbei angenommene Koordinatensystem ist das Weltkoordinatensystem in ParaView. Um mehrere Ausgabefenster auf dem gleichen Rechner zu erzeugen, genügt ein weiteres \textit{Machine} Element mit dem gleichen \textit{Name} Attribut. Für jedes Ausgabefenster muss jedoch beim Starten des Servers wie MPI mindestens ein Prozess zur Verfügung stehen (Abb. \ref{lst:ParaViewCmdExample} Startparameter \textit{-np 2} für zwei Prozesse).\\
Mit diesen ParaView Renderserver habe ich Paraview erfolgreich auf dem Desktop System und der Powerwall des Lehrstuhl für Multimedia-Technologie getestet. Leider lässt sich nie das ganze LHRD zur Ausgabe benutzen, da die Interaktion mit Paraview weiterhin nur über den Client funktioniert. Somit muss dieser immer mit angezeigt werden. Da ParaView keine Konfiguration zur Verfügung stellt, mit der man Stereoprojektion in separaten Fenster ausgeben kann, habe ich auf einen Test auf der Stereopowerwall der Professur für Computergraphik und Visualisierung verzichtet.\\
Durch die Möglichkeit des Remote Rendering auf einem Cluster sollte ParaView auch sehr gut in der CAVE des Lehrstuhl Konstruktionstechnik/CAD laufen. Die durch die PVX Konfigurationsdateien gegebene Möglichkeit mehrere Viewports mit verschiedenen Blickrichtungen zu konfigurieren, ermöglicht eine immersive Visualisierung in der CAVE. Die Kommunikation zwischen den Servern im Cluster wird mittel MPI ermöglicht. Leider konnte ich ParaView nicht erfolgreich in der CAVE des Lehrstuhl Konstruktionstechnik/CAD ausführen und testen. Mir ist es nicht gelungen MPI so auszuführen und zu testen, dass es die ParaView Render Server auf dem Cluster ausführt. Unter Windows war es mir nicht möglich mittels MPI einen Prozess auf einem anderen Windows Rechner zu starten, der sich im gleichen Netzwek befand. Mir ist es nicht gelungen Windows so zu konfigurieren, dass das Starten von Prozessen via Remote erlaubt wurde. Deshalb sind die Konfigurationen von ParaView bezüglich der CAVE des Lehrstuhl Konstruktionstechnik/CAD nur theoretischer Natur.
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
mpirun -np 2 pvserver.exe -display localhost:0 datei.pvx
\end{lstlisting}
\caption{Beispielbefehl zum Starten des ParaView Servers mit Startparametern}
\label{lst:ParaViewCmdExample}
\end{figure}
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
<?xml version="1.0" ?>
<pvx>
<Process Type="client" />
<Process Type="render-server">
	<Machine Name="Links"
             Environment="DISPLAY=:0"
             Geometry="1600x1200+0+0"
             FullScreen="0"
             ShowBorders="0"
             LowerLeft="-1.8 -1.35 1.8"
             LowerRight="-1.8 -1.35 -1.8"
             UpperRight="-1.8 1.35 -1.8">
	</Machine>
	<Machine Name="Vorn"
             Environment="DISPLAY=:0"
             Geometry="1600x1200+0+0"
             FullScreen="0"
             ShowBorders="0"
             LowerLeft="-1.8 -1.35 -1.8"
             LowerRight="1.8 -1.35 -1.8"
             UpperRight="1.8  1.35 -1.8">
	</Machine>
</Process>
</pvx>
\end{lstlisting}
\caption{PVX-Datei für LHRD bestehend aus zwei Displays die jeweils von einem Rechner (\textit{Links} und \textit{Vorn}) betrieben werden}
\label{lst:ParaViewPVXExample}
\end{figure}
\subsection*{Equalizer}
Equalizer \cite{EMP:09} ist eine Middleware für die Entwicklung und Ausführung von OpenGL Anwendungen. Mit Equalizer können diese Anwendungen auf unterschiedlich skalierten Systemen, bezüglich Renderleistung oder Displaygröße, ausgeführt werden ohne diese zu verändern. Die Anpassung an die verschiedenen System erfolgt über die Konfiguration. \\
Für die Konfiguration für Equalizer Anwendungen gibt es eqc-Textdateien. In diesen sind die Einstellungen für die Server gespeichert. Darunter auch das Layout für die Ausgabe. Darin können mehrere Views definiert und konfiguriert werden (Abb. TODO). Auch die verschiedenen Stereoeigenschaften lassen sich im Layout konfigurieren.\\
Equalizer habe ich auf keiner der Hardware Installationen getestet sondern habe mich hier lediglich auf die Konfigurationsdatei konzentriert. Dies lag daran, dass die Entscheidung Equalizer mit in die Liste der zu unterstützender Software erst nach der Anforderungsanalyse gefallen ist.


%Kapitel 4 #######################
\chapter{Konzeption}
Das Ziel hinter Open Display Enviroment Configuration Language (OpenDECL) ist es, eine adäquate aber dennoch knappe Beschreibung für LHRD zu entwickeln. Diese Beschreibung sollte all nötigen Informationen enthalten, die für die Konfiguration der Anwendung, die auf dem beschriebenen LHRD ausgeführt werden soll, benötigt werden. Aus der Softwareanalyse ergab sich, dass für eine Konfiguration im wesentlichen zwei Aspekte eine Rolle spielen. Zum einem der Aufbau des LHRD aus einzelnen Displays und der Abbildung der jeweiligen Pixelkoordinaten darauf. Und zum anderem die Infrastruktur die das LHRD betreibt.

\section*{Display Beschreibung}
TODO hier kommt noch ein tolles Bild ähnlich zu dem mit den Vektoren aus meiner Zwischenpräsentation.\\
Zur Beschreibung des Displays ist zum einem die physische Größe und Anordnung der Display Elemente an sich nötig, als auch die Abbildung der Pixelkoordinaten auf diese Displays.\\
Unter der Annahme, dass es sich bei den Displays um Rechteckige Flächen handelt, lässt sich die Breite und Höhe einfach angeben. Für die Positionierung der Displays im Raum ist ein Referenzkoordinatensystem notwendig. Wenn man dieses definiert hat, lassen sich alle Displays positionieren in dem Beispielsweise ein Vektor die Position der linken oberen Ecke des Displays beschreibt. Damit hat man das Display positioniert aber noch nicht orientiert. Dafür sind zwei weitere Vektoren notwendig. Mit drei Vektoren, die Beispielsweise die drei der vier Ecken des Displays beschreiben, lässt sich ein Display ähnlich wie in den PVX Dateien bei der Konfiguration von ParaView eindeutig im Raum platzieren. Damit lässt sich die Anordnung der einzelnen Displays in einem LHRD beschreiben.\\
Die Frage wo man das Referenzkoordinatensystem ansetzt, also wohin man den Ursprung legt, kann auf zwei verschiedenen Wegen geklärt werden. Wenn man kein anderes Koordinatensystem als Anhaltspunkt hat, zum Beispiel durch ein Trackingsystem oder ähnliches, kann man den Benutzer als Ursprung des Referenzkoordinatensystems benutzen. Dazu sucht man sich die bevorzugte Position des Benutzers vor dem LHRD und beschreibt dann ausgehend vom Kopf des Benutzers als Koordinaten Ursprung die Positionierung und Orientierung der einzelnen Displays.\\
Im Fall eines bereits vorhanden Koordinatensystems, beispielsweise durch ein Trackingsystem, können die einzelnen Displays in diesem System positioniert und orientiert werden. In diesem Fall wäre jedoch angebracht auch den Benutzer zu positionieren, da sich dessen Position nicht mehr durch den Koordinatenursprung, wie in dem ersten Fall, ergibt. Der Benutzer kann mit zwei Vektoren beschrieben werden, die die Position und Orientierung seines Kopfes beschreiben.\\
Besonders bei LHRD, die einen erweiterten Desktop abbilden, ist es wichtig auch die Zuordnung der Pixelkoordinaten zu den einzelnen Displays zu beschreiben. Diese Beschreibung ist nötig, da die Ausgabefenster der Anwendungen für das LHRD nur in diesem Pixelraum positioniert werden können. Die naheliegende Lösung dafür sind drei weitere Vektoren zur Beschreibung der einzelnen Displays. Diese Vektoren sind keine Raumvektoren, sondern Pixelvektoren und beschreiben die entsprechenden Ecken des Displays in Pixelkoordinaten.\\
Mit diesen beiden Beschreibungen der Ecken der einzelnen Displays, also räumliche Koordinaten und Pixelkoordinaten, lässt sich das LHRD eindeutig beschreiben und die Anwendungen dafür konfigurieren.

\section*{Infrastruktur Beschreibung}
Die Beschreibung der Infrastruktur ist besonders dann wichtig, wenn mehrere Rechner das LHRD betreiben. Dann ist es wichtig zu wissen, welcher Teil des LHRD von welchem Rechner betrieben wird. Dies lässt sich beschreiben, indem man für jeden Rechner angibt, mit welchen Displays er verbunden ist. Zusammen mit der Beschreibung der Displays, lässt sich so einfach beschreiben, welcher Rechner für welchen Teil des LHRD zuständig ist.\\
Bezüglich der Verbindung der Rechner untereinander, gehe ich von einem Ethernet Netzwerk aus, was von allen Rechnern geteilt wird. Da es in einem solchen Netzwerken keine gerichteten Verbindungen gibt, genügt es zu beschreiben, in welchen Netzwerken sich die Rechner befinden und welche Adressen sie darin haben.

%Kapitel 5 #######################
\chapter{OpenDECL-Spezifikation}
TODO fancy Infografik mit Überblick und Referenzpfeilen\\
Die aus meiner Konzeption hervorgehende benötigten Beschreibungen für LHRD, habe ich in die Spezifikation der OpenDECL Dokumente umgesetzt. Diese Spezifikation liegt als XML Schema Document auf dem beigelegtem Datenträger vor und besteht im grob aus zwei Teilen. Zum einem die Beschreibung der Infrastruktur mit den \textit{node} und \textit{network} Elementen und der Beschreibung des LHRD in den \textit{display-setup} Elementen. Ein gültiges OpenDECL Dokument benötigt dabei beliebig viele aber mindestens ein \textit{node} Element, beliebig viele \textit{network} Elemente und beliebig viele aber mindestens ein \textit{display-setup} Element. Abbildung TODO zeigt einen Überblick, wie die einzelnen Elemente verschachtelt sind und auf welche Elemente die Referenzen verweisen. Im folgenden werden die einzelnen Elemente und deren Attribute der Spezifikation näher beschrieben und welche Aspekte der Konzeption damit umgesetzt werden.

\section{node}
Das \textit{node} Element beschreibt einen Rechner. Würde das LHRD also von einem Cluster betrieben, gäbe es in der OpenDECL Beschreibung dafür auch mehrere \textit{node} Elemente. Das \textit{id} Attribut beschreibt einen eindeutigen Bezeichner für den Rechner und ist ein Pflichtattribut. Dies kann Beispielsweise der Name des Rechners im Netzwerk sein. Das \textit{purpose} Attribut ist optional und kann die Funktion des Rechners beschreiben. Solche Funktionen können zum Beispiel "'Rendern"', "'Verarbeitung"' oder "'Berechnung"' sein.\\
Ein \textit{node} Element und damit ein Rechner, kann beliebig viele \textit{graphics-device} und \textit{network-device} Elemente enthalten.

\subsection{graphics-device}
Das \textit{graphics-device} Element beschreibt eine Grafikkarte in einem Rechner. Das \textit{id} Attribut dient als eindeutiger Bezeichner für diese Grafikkarte und ist ein Pflichtattribut. Das \textit{gpu-count}, \textit{vram} und \textit{model-name} Attribut sind optionale Attribute um die Grafikkarte bezüglich Anzahl der GPUs, Speicher und Model Namen näher zu beschreiben.\\
Ein \textit{graphics-device} Element enthält beliebig viele aber mindestens ein \textit{port} Element. Dies schließt zwar nVidia Tessla-Karten aus, welche nur GPU-Computing leisten und keinen Displayanschluss haben. Da sich aber diese Spezifikation auf die Displaybeschreibung konzentriert, habe ich diesen Fall außer Acht gelassen.

\subsection*{port}
Das \textit{port} Element beschreibt einen Anschluss an der Grafikkarte, an den ein Display angeschlossen werden kann. Das \textit{id} Attribut dient als eindeutiger Bezeichner dieses Anschlusses und dient als Referenz ID für die Zuordnung von Displays an diesen Anschluss. Das \textit{type} und \textit{slot} sind optionale Attribute um diesen Anschluss näher zu beschreiben, beispielsweise ob es sich um einen HDMI oder VGA Anschluss handelt oder welcher Anschluss bei Grafikkarten mit mehreren Anschlüssen beschrieben wird.

\subsection{network-device}
Das \textit{network-device} Element beschreibt einen Netzwerk Adapter, der mit einem Netzwerk verbunden ist. Das \textit{id} Attribut dient als eindeutiger Bezeichner dieses Netzwek Adapters und ist, wie alle anderen Attribute von \textit{network-device}, ein Pflichtattribut. Das Attribut \textit{network} ist eine Referenz auf ein \textit{network} Element mit der angegebenen \textit{id}. Damit ist dieser Netzwerk Adapter und damit auch der Rechner in dem dieser angegeben ist, mit dem angegebenen Netzwerk verbunden. Das Attribut \textit{address} gibt dabei die entsprechende Adresse des Netzwerk Adapters im Netzwerk an.

\section{network}
Das \textit{network} Element beschreibt ein Netzwerk für mehrere Rechner. Das \textit{id} Attribut dient als eindeutiger Bezeichner des Netzwerks und ist ein Pflichtattribut. Es dient als Referenz ID für die Zuordnung von Netzwerk Adapter die mit diesem Netzwerk verbunden sind. Die Attribute \textit{bandwidth} und \textit{subnet-mask} sind optionale Attribute und dienen zur näheren Beschreibung des Netzwerkes.\\
\\
Ein Beispiel für die Beschreibung der Infrastruktur mittels \textit{node} und \textit{network} sieht man in Abb. \ref{lst:NodeAndNetworkExample}. Dies ist die Beschreibung des Desktop System.\\
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
<node id="Ronald-PC" purpose="render">
	<graphics-device id="video1" gpu-count="1" vram="512" 
	model-name="ATi Radeon HD 3650 mobility">
		<port type="display" id="M1" slot="onboard"></port>
		<port type="display" id="M2" slot="HDMI 1"></port>
	</graphics-device>
	<network-device type="ethernet" id="EA1" network="e1" address="127.0.0.1" />
</node>
<network id="e1" bandwidth="10 Gbit/s" subnet-mask="255.255.255.0" />
\end{lstlisting}
\caption{Beschreibung der Infrastruktur des Desktop System}
\label{lst:NodeAndNetworkExample}
\end{figure}

\section{display-setup}
Das Element \textit{display-setup} stellt eine mögliche Konfiguration von Displays dar. Sind die Displays auf verschiedenen Arten konfigurierbar, so lässt sich dies mit mehreren \textit{display-setup} Elementen abbilden. Das Attribute \textit{id} dient als eindeutiger Bezeichner und ist ein Pflichtattribut. Das Attribut \textit{eye-distance} beschreibt den Augenabstand der für die Stereoprojektion verwendet wird. Wird dieser nicht angegeben, so wird standardmäßig der Wert \textit{0.0} angenommen.\\
Ein \textit{display-setup} Element kann ein \textit{user} Element enthalten, sowie mindestens ein oder beliebig viele \textit{display} Elemente.

\subsection*{vector}
Das Element \textit{vector} stellt einen zwei- oder dreidimensionalen Vektor dar. Dieser wird für die Beschreibung des Benutzer im Element \textit{user} benutzt, sowie für die physische und virtuelle Positionierung der Displays im Element \textit{display}. Mit den Attributen \textit{x}, \textit{y} und \textit{z} lassen sich die Komponenten des Vektors angeben. Dabei sind \textit{x} und \textit{y} Pflichtattribute und \textit{z} optional. Damit lässt sich das \textit{vector} Element zur Darstellung für zwei- und dreidimensionale Vektoren verwenden.

\subsection{user}
Das Element \textit{user} stellt den Benutzer in der aktuellen Konfiguration dar. Wird der Benutzer mit diesem Element nicht beschrieben, wird angenommen, dass er sich im Ursprung des angenommenen Koordinatensystem befindet.\\
Das Element \textit{user} muss ein \textit{position} und ein \textit{orientation} Element enthalten, mit denen der Benutzer beschrieben wird. Diese beiden Elemente müssen jeweils ein \textit{vector} Element enthalten. Dabei beschreibt das Element \textit{position} die Position des Benutzers und das Element \textit{orientation} die Blickrichtung des Benutzers an dieser Position im angenommenen Koordinatensystem.

\subsection{display}
Das Element \textit{display} stellt eine Displayfläche dar. Dabei wird nur die reine darstellende Fläche beschrieben. Das heißt im Falle eines Projektors, die Fläche die von diesem bestrahlt wird und im Falle eines Monitors ist dies der Bildschirm ohne den Rahmen. Das Attribut \textit{id} dient als eindeutiger Bezeichner innerhalb einer Konfiguration und ist ein Pflichtfeld. Mit dem Pflichtattribute \textit{portref} referenziert man auf das \textit{id} Attribut eines \textit{port} Elementes. Damit stellt man die Verbindung dieses Displays mit einem Port und damit einem Rechner dar. Mit den Pflichtattributen \textit{pixel-size-x},\textit{pixel-size-y},\textit{metric-size-x} und \textit{metric-size-y} wird die Auflösung und physische Größe des Displays beschrieben. Wenn es sich um ein Display für eine stereoskopische Abbildung handelt, kann mit dem Pflichtattribute \textit{stereo} angegeben werden, für welches Auge das Display abbildet (\textit{left-eye} order \textit{right-eye}). Wenn es sich nicht um eine stereoskopische Abbildung handelt, wird dies mit mit \textit{none} angegeben. Mit dem optionalen Attribut \textit{type} kann das Display näher beschrieben werden, zum Beispiel ob es sich um einen Monitor oder Projektor handelt.\\
Das \textit{display} Element muss jeweils ein \textit{physical} und ein \textit{virtual} Element enthalten.

\subsection*{physical und virtual}
Mit dem \textit{physical} Element wird die Position des Display im angenommenen Koordinatensystem beschrieben. Jedes \textit{physical} Element muss jeweils ein \textit{upper-left},\textit{lower-left},\textit{lower-right} und \textit{upper-right} Element enthalten, welche wiederum jeweils ein \textit{vector} Element enthalten. Diese Elemente beschreiben jeweils die vier Ecken des Displays im Raum. Demnach muss es sich bei den verwendeten \textit{vector} Elementen um dreidimensionale Vektoren handeln.\\
Mit dem \textit{virtual} Element wird die Abbildung der Pixelkoordinaten auf das Display beschrieben. Die geschieht analog zum \textit{physical} Element, in dem jeweils die vier Ecken des Displays mit ihren Pixelkoordinaten beschrieben werden. Der Unterschied besteht darin, das die verwendeten \textit{vector} Elemente zweidimensionale Vektoren beschreiben.\\
\\
Ein Beispiel für die Beschreibung einer Konfiguration mit Benutzer und einem von zwei Displays sieht man in Abb. \ref{lst:DisplaySetupExample}. Die kompletten Beschreibungen der Installationen mittels openDECL Dokumenten befinden sich auf dem beigelegten Datenträger. Dabei habe ich bei den Größen- beziehungsweise Auflösungsangaben in den Beschreibungen und Vektoren jeweils Meter und Pixel verwendet.\\
\begin{figure}[htbp]
\begin{lstlisting}[frame=trbl]
<display-setup id="flat">
	<user>
		<position>
			<vector x="0" y="0" z="0"></vector>
		</position>
		<orientation>
			<vector x="0" y="0" z="-1"></vector>
		</orientation>
	</user>
	<display id="Mon1" portref="M1" type="monitor" stereo="none" 
	pixel-size-x="1280" pixel-size-y="800" metric-size-x="0.32" metric-size-y="0.2">
		<physical>
			<upper-left>
				<vector x="-0.32" y="0.1" z="-0.5"></vector>
			</upper-left>
			<lower-left>
				<vector x="-0.32" y="-0.1" z="-0.5"></vector>
			</lower-left>
			<lower-right>
				<vector x="0" y="-0.1" z="-0.5"></vector>
			</lower-right>
			<upper-right>
				<vector x="0" y="0.1" z="-0.5"></vector>
			</upper-right>
		</physical>
		<virtual>
			<upper-left>
				<vector x="0" y="0"></vector>
			</upper-left>
			<lower-left>
				<vector x="0" y="800"></vector>
			</lower-left>
			<lower-right>
				<vector x="1280" y="800"></vector>
			</lower-right>
			<upper-right>
				<vector x="1280" y="0"></vector>
			</upper-right>
		</virtual>
	</display>
\end{lstlisting}
\caption{Beschreibung einer Konfiguration mit Benutzer und einem Display}
\label{lst:DisplaySetupExample}
\end{figure}


%Kapitel 6 #######################
\chapter{XSLT-Konfigurationsgenerierung}
was ist zu beachten\\
wie viel logik kann man in XSLT reinstecken, wo liegen die Grenzen?\\

\section{Beispiel}
TODO\\
einfaches Beispiel CGV Stereowall mit Megamol\\
komplexeres Beispiel MT Powerwall mit Paraview\\
hypothetisches Beispiel für CAVE mit Paraview\\

%Kapitel 7 #######################
\chapter{Editor}

\section{Funktionen}
Was kann Editor\\
Wo liegen Grenzen des Editors\\
kleines Manual\\

\section{Umsetzung}
Grober Aufbau\\
Datenhaltung im Hintergrund\\
Zugriff via Interface\\

%Kapitel 8 #######################
\chapter{Evaluation}
Wie gut Erfüllt Ergebnis die Aufgabenstellung\\
Wie gut lassen sich die XSLTs erstellen\\
Wie ist die Qualität der Konfigurationen die hinten raus kommen\\

%Kapitel 9 #######################
\chapter{Diskussion}
Vergleich Ergebnis mit Vorgaben, Ideen, Konzeption\\

%Kapitel 10 ######################
\chapter{Ausblick}
Mögliche Erweiterungen\\
Ausgelassene oder vereinfachte Aspekte, die noch Ausbaufähig sind\\
weitere Optionen für Editor\\
\begin{figure}[htbp]
	\centering
		\includegraphics{test.png}
	\caption{beschriftung}
	\label{fig:diplominf}
\end{figure}

\end{document}